- Join
    
    **정의**
  
    2개 이상의 테이블을 연결하여 데이터를 검색하는 방법
  
    
    **종류**
    
    1. inner join : join 조건에서 값이 일치하는 값만 join
    2. natural join : 기준 테이블과 조인 테이블에서 동일한 이름을 가진 칼럼들이 자동으로 join
    3. outer join : 어느 한 테이블의 데이터를 모두 가져오는 join
    4. cross join : 곱집합 → 조인 시 가능한 모든 경우의 수를 join
    
- N+1 문제
    
    **정의** 
    
    연관 관계가 설정된 엔티티를 조회할 경우 조회된 데이터 갯수(n) 만큼 연관관계의 조회 쿼리가 추가로 발생해서 데이터를 읽어 오는 현상 (따라서 n+1 보다는 1+n 문제가 더 맞는 표현이라고 생각합니다!)
    
    **발생 이유**
    
    그럼 일반 sql문은 N+1 문제가 발생하지 않는데 JPA에서는 N+1 문제가 발생하는 이유는 뭘까?
    
    그 이유는, JPA는 영속성 컨텍스트, 프록시 등을 활용해서 DB가 아닌 객체 중심으로 설계 됐기 때문이다.
    
    oop라 불리는 객체지향은 구현하고자 하는 기능을 만들어 놓고  필요할 때 object를 사용하는 기술이다. 여기서 중요한 포인트는 **필요할 때 마다 사용한다**는 것이다.
    
    즉 JPA 또한 객체 지향이므로 영속성 컨텍스트의 값을 찾아보고 **필요할 때마다 DB에 접근**하는데,
    
    join으로 연결된 값은 영속성 컨텍스트에 들어가지 않으므로 결국 join 된 값이 **필요할 경우 값이 필요할 때마다 영속성 컨텍스트 탐색 후 DB에서 쿼리를 날린다는 의미가 된다** 
    
    출처 : https://programmer93.tistory.com/83
    
- SpringBoot에서 N+1 예방법

    ***1. fetch join 사용***
    
    평소에는 지연 로딩 전략을 쓰다가 join이 필요할 때 fetch를 적용함으로 필요할 때 한 번에 데이터를 가져올 수 있게 한다. 즉 join 시 모든 정보가 다 영속성 컨텍스트에 들어가므로 필요할 때마다 값을 불러도 쿼리문이 계속 나가는 문제 해결 가능
    
    **사용 방법**
    
     쿼리 작성 시 명시적으로 fetch join을 지정함으로써 사용할 수 있다
    
    
    ***~~2. Eager Loading 사용~~(x)***
    
    JPA가 JPQL를 분석해서 SQL을 생성할 때 영속성 컨텍스트에 정보를 가져오는 전략으로 
    
    즉시로딩을 선택하는 방법이 있는데..
    
    즉시 로딩은 해결책이 될 수 없을 뿐더러 더욱 상확이 악화될 수 있다.
    
    그 이유는 Eager은 Hibernate가 판단해서 로딩을 하기 때문이다. 따라서 Hibernate가 자동으로 가져오기 때문에 언제 로딩하는지 알 수 없어 N+1 문제가 발생할 수 있고, 미리 로딩 됐다 하더라도 엔티티 안에 연관관계가 있는 객체들에서 내부적으로 N+1가 **최악의 상황에서는 여러 번 발생할 수 있으므로** 가급적 지연 로딩 전략을 기본으로 세워야 한다.
    
    ***3. EntityGraph 사용***
    
    **@EntityGraph는** Data JPA에서 fecth 조인을 어노테이션으로 사용할 수 있도록 만들어 준 기능이다.
    
    → fetch를 어노테이션으로 연결하다는 점에서 편하다고 했지만 관계를 얽히면 오히려 복잡해진다는 말도 많네요 ㅎㅎ
    
    ***4. Batch size 조정***
    
    연관된 엔티티를 하나씩 이 아닌 설정한 Batch size 만큼 가져오게 한다.
    
    예를 들어 Batch size를 1000으로 조정했다면 추가로 1000개의 정보를 묶음으로 가져오게 된다.
    
    - **그러면 fetch join이랑 다를게 없지 않을까?**
    
    Batch size의 장점
  
        1. 영속성 컨텍스트에 다 저장하지 않으므로 메모리 효율성 증가
        2. 페이징이 안 되는 fetch join 만의 문제결
    
    개인적으로 각각의 기술을 잘 쓰면 JPA로도 복잡한 쿼리를 구현할 수 있지만, 하나하나 오류를 파다 보면 끝도 없이 나올 때도 많아서 이걸 다 공부하기는 쉽지 않고,
    
    복잡한 쿼리가 나올 때는 jdbcTemplate를 사용하거나 혹은, 요즘 jdbcClient라는 훨씬 더 간결하고 유연한 쿼리를 작성 가능한 기술이 나와서 해당 기술에 대해 공부하는 것이 더 트렌드에 맞지 않는가 라고 생각합니다
