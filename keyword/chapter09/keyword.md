- Spring Data JPA의 Paging
    
    *Spring Data JPA는 **페이징**을 위해 두 가지 객체를 제공하는데 이것이 바로 Slice와 Page*
    
    **페이징**
    
    : 사용자가 어떠한 데이터를 요청했을 때, 전체 데이터 중 일부를 원하는 정렬 방식으로 보여주는 방식
    
    **페이징은 적용 방법**
    
    페이징 기법 구현을 위해 기본적으로 알아야 하는 파라미터들이 있습니다.
    
    - **page** : 페이징 기법이 적용되었을 때, 원하는 페이지
    - **size** : 해당 페이지에 담을 데이터 개수
    - **sort** : 정렬 기준
    
    이 파라미터들을 Pageable 구현체에 담아 페이징을 설정
    
    - Page
        
        Pageble을 파라미터로하여 가져온 결과물은 `Page<SomeObject>` 형태로 반환 되며, Page를 사용한다면 대부분 다수의 row를 가져오기 때문에 `Page<List<SomeObject>>`의 형태로 반환을 한다. 이 페이지 객체에는 Pagination을 구현할 때 사용하면 좋은 메서드가 있으며 이는 다음과 같다.
        
        ### getTotalElements()
        
        쿼리 결과물의 전체 데이터 개수이다. 즉, Pageable에 의해 `limit`키워드가 조건으로 들어가지 않는 쿼리 **결과의 수** 인데, 주의해야 할 점은 쿼리 **결과의 갯수만** 가져오지 **전체 데이터를 가져오지 않는다**는 점이다.
        
        이 메서드는 게시판 기능 사용자에게 전체 데이터 개수를 알려주는 등에 사용하기 좋다.
        
        ### getTotalPages()
        
        쿼리를 통해 가져온 요소들을 size크기에 맞춰 페이징하였을 때 나오는 총 페이지의 갯수이다.
        
        이를 활용해 쉽게 페이지 버튼의 생성이 가능하다.
        
        ### getSize()
        
        쿼리를 수행한 전체 데이터에 대해 일정 수 만큼 나눠 페이지를 구성하는데, 이 일정 수의 크기이다.
        
        ### getNumber()
        
        요소를 가져온 페이지의 번호를 의미한다.
        
        ### getNumberOfElements()
        
        페이지에 존재하는 요소의 개수이다. 최대 size의 수 만큼 나올 수 있다.
        
    - Slice
        - **다음 슬라이스 존재 여부**
            - 요청한 페이지 크기보다 `+1` 만큼 더 조회해 보고, 그 결과로 `hasNext()` 판단
        - **메서드**
            - `List<T> getContent()`
            - `boolean hasNext()`
            - `boolean hasPrevious()`
            - `Pageable getPageable()`, `Pageable nextPageable()`
        - **장점**
            - **count 쿼리 생략** → 빠른 응답
        - **단점**
            - 전체 건수·전체 페이지 수 정보가 필요할 때 사용 불가
- 객체 그래프 탐색
    - **객체(node)**: JPA 엔티티 클래스 하나하나
    - **연관(edge)**: @OneToMany, @ManyToOne와 같은 필드 매핑
    - 이 둘이 연결되어 마치 **트리(tree)** 또는 **네트워크(graph)**처럼 이루어진 구조
    
    ![image.png](attachment:7485b147-b701-419d-99b6-6da4e8077df9:image.png)
    
    **객체 그래프 탐색의 요소**
    
    - **로딩 전략 (FetchType)**
        - **EAGER**: 연관된 엔티티를 즉시 함께 조회
        - **LAZY**: 실제 사용할 때(필드 호출 시) 조회
    - **영속성 컨텍스트 (Persistence Context)**
        - 한번 로드된 엔티티는 1차 캐시에 보관
        - 동일 트랜잭션 내에 다시 조회하면 1차 캐시에서 반환 → 중복 쿼리 방지
    - **프록시 (Proxy)**
        - LAZY 연관관계일 때, 실제 엔티티 대신 가짜 객체를 미리 만들어 두고
        - 접근 시점에 실제 데이터를 조회
