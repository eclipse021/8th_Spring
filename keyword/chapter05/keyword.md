## Domain

JPA에서의 Entity는 Java 객체를 데이터베이스 테이블에 매핑하기 위해 사용되는 객체이다.

이 Entity에 attribute 외에도 increaseLikeCount와 같은 비즈니스 로직이 포함 될 수 있다.

즉, Domain이란 데이터와 데이터를 다루는 메서드를 합친 개념이라고 할 수 있다.

## 양방향 연관관계

### 정의

양방향 연관관계는 두 엔티티가 서로를 참조하는 관계를 의미한다. 예를 들어, Member 엔티티가 Team 엔티티를 참조하고, 동시에 Team 엔티티도 Member 엔티티를 참조하는 경우가 있다. DB에서는 양쪽으로 서로 연관되어 있지만 이를 JPA에서는  두 개의 단방향 연관관계를 설정(=양방향)하여 구현한다.

### 연관관계의 주인

양방향 연관관계에서는 반드시 **연관관계의 주인**을 지정해야 한다. 연관관계의 주인만이 외래 키를 관리(등록, 수정, 삭제)할 수 있으며, 주인이 아닌 쪽은 읽기만 가능합니다.

- **주인 쪽**: mappedBy 속성을 사용하지 않습니다.
- **주인이 아닌 쪽**: mappedBy 속성을 사용하여 주인을 지정합니다.

연관관계의 주인은 보통 외래 키를 가진 엔티티로 설정합니다(1대 N 관계라면, N쪽을 주인으로 지정). 위의 예시를 대입하면 Member 엔티티가 Team 엔티티를 참조하며 외래 키를 가진다면, Member 엔티티가 연관관계의 주인이 됩니다.

(주인 쪽만 연관관계를 설정해도 연관관계가 맺어지지만 java의 객체의 특징을 활용하기 위해 양쪽 모두 선언해주는 것이 좋다)

## N+1 문제

### 정의

연관 관계가 설정된 엔티티를 조회할 경우 조회된 데이터 갯수(n) 만큼 연관관계의 조회 쿼리가 추가로 발생해서 데이터를 읽어 오는 현상 (따라서 n+1 보다는 1+n 문제가 더 맞는 표현이라고 생각합니다!)

### 발생 이유

그럼 일반 sql문은 N+1 문제가 발생하지 않는데 JPA에서는 N+1 문제가 발생하는 이유는 뭘까?

그 이유는, JPA는 영속성 컨텍스트, 프록시 등을 활용해서 DB가 아닌 객체 중심으로 설계 됐기 때문이다.

oop라 불리는 객체지향은 구현하고자 하는 기능을 만들어 놓고  필요할 때 object를 사용하는 기술이다. 여기서 중요한 포인트는 **필요할 때 마다 사용한다**는 것이다.

즉 JPA 또한 객체 지향이므로 영속성 컨텍스트의 값을 찾아보고 **필요할 때마다 DB에 접근**하는데,

join으로 연결된 값은 영속성 컨텍스트에 들어가지 않으므로 결국 join 된 값이 **필요할 경우 값이 필요할 때마다 영속성 컨텍스트 탐색 후 DB에서 쿼리를 날린다는 의미가 된다**
